import { QueryParams } from "./QueryParams";
import * as fs from "fs";
import { getDayBeforeTime } from "./time";
import { processData } from "./processData";
import { GenerationValues } from "./GenerationValues";

const apiKey: string = fs.readFileSync("./api_key.txt", "utf8");

// print out percentage of energy generated by this BA
export async function generationPercentage(
    BA: string,
    fueltype?: string[],
    reuse: boolean = false
): Promise<GenerationValues[] | number[]> {
    const generationQueryParams: QueryParams = {
        api_key: apiKey,
        frequency: "hourly",
        data: ["value"],
        facets: [["respondent", BA]],
        start: getDayBeforeTime(),
        end: null,
        sort: [
            {
                column: "period",
                direction: "desc",
            },
        ],
        offset: "0",
        length: "5000",
    };

    if (fueltype) {
        // add fueltype at the beginning
        fueltype.unshift("fueltype");
        generationQueryParams.facets?.push(fueltype);
    }

    const data: GenerationValues[] = await processData("generation", generationQueryParams);
    if (reuse) {
        return data;
    } else {
        let total = data.reduce((sum, current) => sum + current.value, 0);
        console.log(`Net generation for ${BA}:`);
        return data.map((n) => {
            const percentage = (n.value / total) * 100;
            console.log(
                `${n["type-name"]} is ${percentage.toFixed(2)} wtih value ${n.value} ${
                    n["value-units"]
                }`
            );
            return percentage;
        });
    }
}

export async function generationInterchangePercentage(
    BA: string,
    fueltype?: string[],
    reuse: boolean = false
) {
    const interchangeQueryParams: QueryParams = {
        api_key: apiKey,
        frequency: "hourly",
        data: ["value"],
        facets: [
            ["respondent", BA],
            ["type", "TI"],
        ],
        start: getDayBeforeTime(),
        end: null,
        sort: [
            {
                column: "period",
                direction: "desc",
            },
        ],
        offset: "0",
        length: "5000",
    };

    // generationData will always be of type GenerationValues when reusing a panel
    const generationData: GenerationValues[] = (await generationPercentage(
        BA,
        fueltype,
        true
    )) as GenerationValues[];
    // There will be only one latest interchange value
    const interchange = (await processData("multiple", interchangeQueryParams))[0];
    interchange.value = -interchange.value;
    generationData.push(interchange);
    if (reuse) {
        return generationData;
    } else {
        // interchange is always negative
        let total = generationData.reduce((sum, current) => sum + current.value, 0);
        console.log(`Net generation for ${BA}:`);
        return generationData.map((n) => {
            const percentage = (n.value / total) * 100;
            console.log(
                `${n["type-name"]} is ${percentage.toFixed(2)} wtih value ${n.value} ${
                    n["value-units"]
                }`
            );
            return percentage;
        });
    }
}
